%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Implementierung der Relay Attacke}
\label{sec:problemdescription}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Ziel dieses Kapitels ist die Beschreibung der praktischen Durchführung der NFC Relay Attacke. Es soll gezeigt werden, dass es mithilfe weniger Modifikationen am Android Betriebssystem möglich ist, die NFC Signale eines POS Terminals an ein zweites mobiles Gerät weiterzuleiten und auf diesem eine mobile Zahlung zu initiieren. Es wird dargestellt, auf welche Art und Weise ein Eingreifen in die Kommunikation der Zahlungsanwendung mit der NFC Schnittstelle möglich ist und wie die Antwortsignale der Zahlung an das weit entfernte POS Terminal zurückgesendet werden können. 

Ebenfalls soll diskutiert werden, welche unterschiedlichen Komponenten zum Aufbau und zur Durchführung der Relay Attacke notwendig sind, wie diese implementiert wurden und welche Rolle sie bei der Durchführung der Attacke einnehmen. Auftretende Schwierigkeiten sowie getroffene Entscheidungen sollen ebenfalls dargelegt werden.

Am Ende dieses Kapitels soll eine funktionsfähige Proof-of-Concept Implementierung der Relay Attacke stehen, deren Umsetzung mit einfachen Methoden des Android Frameworks realisiert wird und die als Grundlage für weiterführende Forschungen dienen soll. 

\section{Aufbau der Implementierung}

Zur Durchführung der Attacke wurden zwei handelsübliche, NFC-fähige Android Smartphones für die Rolle des Angreifers sowie des Opfers verwendet. Auf dem Angreifer-Gerät, einem HTC U11, war hierbei die Android Version 8.0.0 (API 26) vorhanden, auf dem Opfer-Gerät, einem Google Nexus 5X wurde eine modifizierte Version des Android Open Source Projektes mit der Version \textbf{XXX} installiert. Welche Modifikationen an diesem Betriebssystem vorgenommen wurden, wird in Kapitel \textbf{XXX} detailliert beschrieben.

Umgesetzt wurde die Relay Attacke durch die Entwicklung einer Proof-of-Concept Hostcard Emulation App, die eine handelsübliche mobile Payment Applikation wie beispielsweise Android Pay simulieren soll. Diese Anwendung wurde auf dem Opfer-Gerät installiert und als Ziel der Attacke sollte die HCE App zur Durchführung einer Zahlung und Weiterleitung der Daten an den Angreifer angeregt werden, ohne dass sich das Opfer in der Nähe eines POS Terminals befindet. Die Entwicklung der HCE App wird in Kapitel \textbf{XXX} dargelegt. 

Die Kommunikation der Geräte wurde durch eine weitere mobile Anwendung, welche unabhängig von der HCE Applikation operiert, realisiert. Diese existiert sowohl auf dem Angreifer- als auch auf dem Opfer-Gerät und sorgt für eine Verbindung zwischen den Kommunikationspartnern über ein Wireless Local Area Network (WLAN). 

Diese Anwendung kommuniziert darüber hinaus auch mit dem Android Betriebssystem und sorgt für die Ausführung der HCE App, sobald ein Signal vom Angreifer-Gerät empfangen wird. Darüber hinaus wird auch die Antwort der HCE App, die eigentlich an die NFC Schnittstelle gesendet wird, ebenfalls von der Kommunikationsanwendung abgefangen und an den Angreifer weitergeleitet. Mit welchen Mechanismen die unterschiedlichen Kommunikationswege umgesetzt wurden, wird in Kapitel \textbf{XXX} genauer ausgeführt. 

Zur erfolgreichen Durchführung der Attacke sind Modifikationen am Android Betriebssystem notwendig. Diese sorgen dafür, dass die entwickelten Anwendungen die passenden Signale erhalten, um korrekt operieren zu können. Bei der Durchführung der Attacke wird angenommen, dass eine modifizierte Version des Android Source Codes auf dem Opfergerät installiert werden kann.
Die genaue Durchführung der Änderungen am Android Betriebssystem wird in Kapitel \textbf{XXX} beschrieben. 

In folgender Abbildung ist eine Übersicht der Relay Attacke und der zur Durchführung entwickelten Komponenten gegeben. 

\begin{figure}
	\centering
	\caption{Übersicht der Relay Attacke}
\end{figure}

In Abbildung \textbf{XXX} ist in erster Linie ein POS Terminal sowie ein Angreifer- und ein Opfer-Gerät dargestellt. Das POS Terminal wird durch eine Terminal Simulator Software auf dem Computer dargestellt. Über eine Universal Serial Bus (USB) Verbindung wird von einem NFC Reader die NFC Funktionalität zur korrekten Funktionsweise der Terminal Software bereitgestellt. 

 Bei Kontakt mit dem Angreifer wird vom POS Terminal eine kontaktlose Zahlung über NFC eingeleitet. Die Commmand Apdus werden hierbei direkt in der Kommunikationsanwendung empfangen. Diese nutzt nach dem Empfang eines Kommandos die WLAN Verbindung, um das Apdu an das Opfer weiterzuleiten. Die Kommunikationsanwendung, die auf dem Opfer-Gerät standardmäßig im Hintergrund aktiv ist, empfängt die Signale, woraufhin sie eine Kommunikation über das Betriebssystem mit der auf dem Opfer vorhandenen HCE Applikation startet. Die Rolle dieser HCE Applikation kann im Prinzip von jeder handelsüblichen Mobile Payment Anwendung übernommen werden. Diese Anwendung ist das eigentliche Ziel des Angriffes. Nachdem sie vom Betriebssystem gestartet wurde, wird eine mobile Zahlung in die Wege geleitet. 
Bei der Durchführung der Zahlung von der Zahlungsapplikation Response Apdus an die NFC Schnittstelle des Gerätes gesendet, nachdem die HCE Anwendung davon ausgeht, durch NFC aufgerufen worden zu sein. 
Das modifizierte Betriebssystem leitet nun diese Antworten an die Kommunikationsanwendung zurück, welche diese über WLAN wiederum dem Angreifer mitteilt. Vom Angreifer-Gerät werden die Apdus schlussendlich an das POS Terminal zurückgeleitet und die Relay Attacke wurde erfolgreich durchgeführt. 

In den nachfolgenden Kapiteln wird ausgeführt, wie die einzelnen Komponenten im Detail umgesetzt wurden, um die beschriebene Funktionalität bereitzustellen. 

\subsection{Die Hostcard Emulation Anwendung}

Das Android Framework stellt zur Implementierung einer Hostcard Emulation Anwendung die Klasse HostApduService zur Verfügung. Diese Android-Service Klasse sorgt für das Annehmen von Command Apdus, nachdem diese von der NFC Schnittstelle empfangen wurden. Um diese empfangenen Apdus verarbeiten zu können, muss die Klasse erweitert und die processCommandApdu Methode überschrieben werden. 
Welche Applikation auf ein eintreffendes Command Apdu gestartet werden soll, wird vom Betriebssystem festgestellt. Diese besitzt einen Routing Mechanismus, der auf den sogenannten Application IDs (AIDs) aufgebaut ist \cite{androidHce}. Dies sind Identifier, die Zahlungsanwendungen eindeutig identifizieren können und sie müssen bei der Installation einer Mobile Payment App von dieser beim Betriebssystem durch eine XML-Datei in der Anwendung registriert werden \cite{androidHce}.

Die in dieser Arbeit dargestellte Proof-of-Concept Umsetzung einer HCE Applikation verwendet die AID einer Mastercard MAESTRO Debitkarte, die durch die Hexadezimal Darstellung A0000000043060 identifiziert wird. Gemeinsam mit den Standard Identifiern für Zahlungssysteme, die genau genommen noch vor der eigentlichen Anwendung ausgewählt werden, wird die MAESTRO-AID in der aids.xml Datei festgelegt. 

Diese Datei wird bei der Registrierung der HostApduService Klasse in der AndroidManifest.xml Datei referenziert, um dem Betriebssystem mitzuteilen, welche AIDs von der HCE Anwendung verarbeitet werden können. 

Wird eine Smartcard bzw. ein NFC fähiges Mobilgerät, auf dem eine Zahlungsanwendung vorhanden ist, in die Nähe eines POS Terminals gebracht, so wird von diesem das aus den Grundlagen bekannte SELECT PPSE Kommando gesendet. Nach der Antwort, welche AIDs verarbeitet werden können und dem SELECT AID Kommando wird die implementierte HCE Anwendung über die erweiterte HostApduService Klasse aufgerufen. 
Nach Auswahl der Applikation zur Verarbeitung der Zahlung werden, solange die NFC Verbindung nicht unterbrochen wird, alle nachfolgenden Apdus ebenfalls an diese Klasse weitergeleitet \cite{androidHce}. 

Um eine echte Zahlungsanwendung zu simulieren wurden in der implementierten App die ersten Response Apdus einer echten MAESTRO Debitkarte gespeichert. Als Reaktion auf ein ankommendes Command Apdu wird deshalb das passende Response Apdu zurückgeliefert. 


In diesem Kapitel wird die eigentliche Problemlösung in einem oder mehreren Unterkapiteln ausgeführt. Die Strukturierung dieser Kapitel ist naturgemäß sehr stark von der konkre Aufgabenstellung abhängig. Der Name dieses Kapitels ist anzupassen, z.B. Umfeldbeschreibung -- Fallbeispiel \dots, konkreter schreiben je nach Art Diplomarbeit/Fragestellung.
\makeatletter\ifthesis@masterthesis
Nachfolgend einige Beispiele für unterschiedliche Arten von Diplomarbeiten.

Bei einer Software-Entwicklungsarbeit bieten sich folgende Unterkapitel an:
\begin{itemize}
	\item Im Kapitel \enquote{Design} sollte die konzeptionelle Lösung vorgestellt, diskutiert und begründet werden. Das Ergebnis dieses Kapitels könnte beispielsweise eine Protokoll-Architektur sein.
	\item Im Kapitel \enquote{Modelle} erfolgt üblicherweise das Feindesign. In diesem Kapitel könnten beispielsweise einzelne Protokolle bzw. Algorithmen aus der vorher definierten Protokoll-Architektur eingeführt und diskutiert werden. Achtung: Generell darauf achten, bei der eingangs erläuterten Notation zu bleiben und nicht Synonyme zu verwenden, verwirrt den Leser.
	\item Das Kapitel \enquote{Implementierung} sollte sich dann vorwiegend mit den Details der Umsetzung befassen. In diesem Kapitel sollte nur im Ausnahmefall exemplarisch Quellcode vorgesehen werden. Vielmehr sollten alle Probleme, die bei der Realisierung aufgetreten sind, dokumentiert, interpretiert und die Lösung erläutert werden.
\end{itemize}

Bei einer Arbeit zu einem abstrakteren Thema, bei dem ein oder mehrere Fallbeispiele aus der industriellen Praxis bearbeitet werden, bieten sich folgende Unterkapitel an:
\begin{itemize}
	\item Im Unterkapitel \enquote{Analyse der Problemstellung} wird die konkrete Problemstellung (die Situation im betrachteten Unternehmen) der Fallbeispiele beschrieben. Das Ergebnis dieses Kapitels könnte eine schematische Netzwerk- oder Applikationsarchitektur sein.
	\item Im Unterkapitel \enquote{Fallbeispiel} sollte sich (analog zur Implementierung in der Software-Entwicklung) mit den konkreten Details der Umsetzung befassen. Hier wird dargelegt, wie das zuvor identifizierte Lösungsschema konkret zur Anwendung gelangen kann bzw. welche Probleme während des Umsetzungsprojekts aufgetreten sind.
\end{itemize}

Bei einer Arbeit, deren Grundlage eine Auswahl eines Softwaresystems ist, bieten sich folgende Unterkapitel an:
\begin{itemize}
	\item IST-Analyse
	\item Hardware und Softwareausstattung
	\item Beschreibung der Geschäftsprozesse
	\item Schwachstellenanalyse des Unternehmens
	\item SOLL-Konzeption
	\item Auswahlverfahren möglicher verfügbarer Systeme -- Kriterienkatalog
	\item Einführung des neuen Systems
\end{itemize}

Bei einer Arbeit, deren Fokus auf der Durchführung und Auswertung von Fragebögen liegt, bieten sich folgende Unterkapitel an:
\begin{itemize}
	\item Im Kapitel \enquote{Problemstellung und Fragebogendesign} wird die fachliche Problemstellung detailliert erläutert und der Inhalt des Fragebogens in Bezug zur Problemstellung dargestellt.
	\item Im Kapitel \enquote{Befragungsmethode} werden die Untersuchungsobjekte (z.B. Praktische Ärzte), die Grundgesamtheit (Anzahl praktische Ärzte in Venezuela), Stichprobengesamtheit und das Verfahren zur Stichprobenziehung und das Erhebungsverfahren (Verteilung und Rücklauf der Fragebögen) beschrieben.
	\item Im Kapitel \enquote{Auswertungsmethode} werden die möglichen Auswertungsmethoden aufgelistet und ggf. begründet die ausgewählte Methode beschrieben.
	\item Im Kapitel \enquote{Befragungsdurchführung} wird die Untersuchungsdurchführung (z.B. Zeit, Ort der Befragung, Zeitraum der gesamten Befragung, besondere für das Untersuchungsergebnis oder zukünftige Forschungsarbeiten relevante Vorkommnisse etc.) dargestellt.
\end{itemize}

Hier intensive Rücksprache mit Ihren jeweiligen Fachbetreuern halten, mehrere Diplomarbeiten der Fakultät zu diesem Themenbereich durchsehen. Unabhängig vom Typ der Diplomarbeit werden im nachfolgenden Kapitel die konkreten Ergebnisse beschrieben.
\fi\makeatother